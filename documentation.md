# Haskell Tools Custom Refactoring Guide

##### Let's refactor type signature of `myFunction` from Text to Maybe Text.

```js
    {-# LANGUAGE OverloadedStrings #-}

    module Main where

    import Data.Text

    myFunction :: Text
    myFunction = "Hello World!"
```

##### Before writing our custom refactoring function, we have to carefully observe the AST generated by haskell tool, for this we can use `ht-debug`.

```js
ht-debug <command/-> <workingdir> <modulename> [arguments]
```
##### ht-debug requires 3 arguments - 
- command = refactoring function
- workingdir = path of working directory i.e. path of module where we want to refator the code
- modulename = finally the name of module which is to be refactored

NOTE :: To print the AST, one can use `showTree` command.

That being said, let's observe the tree...

```js
ht-debug showTree /Users/salokya.kumar/Work/haskell-tool/poc/src/app Main
```

<img width="1474" alt="ss1" src="https://github.com/salokyakr/haskell-tools/assets/129846272/de1c96a1-3954-4f01-94af-1a4d3b435e47">

```js
UQualifiedName {_qualifiers = [], _unqualifiedName = UNamePart {_simpleNameStr = "Text"}}
```

If we observe this part of AST, we can see type `Text` is stored in UQualifiedName -> _unqualifiedName -> _simpleNameStr


##### Steps for creating custom refactor function
- Create the module inside `haskell-tool/haskell-tools-mine/src/builtin-refactorings/Language/Haskell/Tools/Refactor/Builtin`, in this case module name is `ChangeMonad`.

-  Add the required imports. 

- Inside `ChangeMonad` module, create the method which is to be invoked via command line. In this case `changeMonad` is the method which will be invoked from command line & `changeMonadLogic` will contain the logic of refactoring.
```js
changeMonadRefactoring :: RefactoringChoice
changeMonadRefactoring = ModuleRefactoring "changeMonad" (localRefactoring changeMonadLogic)
```

- Let's start writing logic for refacotoring, inside `changeMonadLogic` method. We can use `biplateRef` which basically references all the elements accessed by biplate. Back to what we observed in the AST, now we want to capture `UQualifiedName` so that we can parse `_simpleNameStr` to get `Text` and convert it to `Maybe Text`. So for capturing `UQualifiedName`, Haskell Tools has a pattern called `QualifiedName` so if we pass a function with type signature of `QualifiedName`, biplateRef will automatically capture that node in this case it's `UQualifiedName`.

```js
changeMonadLogic :: LocalRefactoring
changeMonadLogic moduleAST =
        do
            !newAST <- liftGhc $ (!~) (biplateRef) (updateMonad) (moduleAST)
            return newAST
```

- Let's create a function `updateMonad` which will take `QualifiedName` as input and depending on case if monad is `Text` it will convert it to `Maybe Text`. Here we are parsing content inside `_simpleNameStr` and if it is `Text`, we are making it `Maybe Text`

```js
updateMonad :: QualifiedName -> Ghc QualifiedName
updateMonad qualName@(QualifiedName qualifiers unqualifiedName) = do
                monad <- (unqualifiedName ^? simpleNameStr)
                let newMonad = "Maybe Text"
                if monad == "Text"
                        then do
                            return $ mkSimpleName newMonad
                else 
                        return qualName
updateMonad qualName = return qualName
```

- In `Language.Haskell.Tools.Refactor.Builtin` import the refactoring function and add it to `builtinRefactorings` list.

- Make sure to add the refactoring function in cabal file also.

- Now to write the changes in module, we have to use `ht-refact` instead of `ht-debug` 
```js
ht-refact /Users/salokya.kumar/Work/haskell-tool/poc/src
```
when it's loaded
```js
changeMonad <module-name>
```
replace `<module-name>` with name of module where you to refactor. Ex - changeMonad Main.

###### All codes are there in the repository, one can take reference from it.
